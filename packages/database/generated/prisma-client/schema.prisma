datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// USER
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                String              @id @default(cuid())
  name              String?
  email             String?             @unique
  emailVerified     DateTime?
  image             String?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @default(now()) @updatedAt
  deleted           Boolean             @default(false)
  deletedAt         DateTime?
  role              Role                @default(USER)
  accounts          Account[]
  budget            Budget[]
  cryptocurrency    Cryptocurrency[]
  sessions          Session[]
  settings          Settings?
  portfolioSnapshot PortfolioSnapshot[]
  CryptoSnapshot    CryptoSnapshot[]
  CashSnapshot      CashSnapshot[]
  PropertySnapshot  PropertySnapshot[]
  SecuritySnapshot  SecuritySnapshot[]
  Asset             Asset[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Settings {
  id                   String       @id @unique @default(cuid())
  userId               String       @unique
  preferredColorScheme ColorScheme? @default(LIGHT)
  userCurrency         String       @default("aud")
  userLanguage         String       @default("eng")
  user                 User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @default(now()) @updatedAt
  deleted              Boolean      @default(false)
  deletedAt            DateTime?

  @@unique([id, userId])
}

enum ColorScheme {
  LIGHT
  DARK
  TBA
}

enum Role {
  USER
  ADMIN
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// LOGS 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

model Log {
  id        String    @id @unique @default(cuid())
  type      LogType
  message   String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?
}

enum LogType {
  info
  warn
  error
  trace
  debug
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// BUDGETS 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

model Income {
  id             String    @id @unique @default(cuid())
  name           String
  payFrequency   String
  grossAmount    String
  grossFrequency String    @default("P1Y0M0DT0H0M0S")
  userId         String
  budget         Budget    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?
}

model Budget {
  id           String           @unique @default(cuid())
  name         String
  userId       String
  user         User             @relation(fields: [userId], references: [id])
  envelopes    BudgetEnvelope[]
  income       Income[]
  totalBalance Decimal          @default(0)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @default(now()) @updatedAt
  deleted      Boolean          @default(false)
  deletedAt    DateTime?
}

model BudgetEnvelope {
  id              String              @id @unique @default(cuid())
  budgetId        String
  name            String
  budget          Budget              @relation(fields: [budgetId], references: [id])
  transactions    BudgetTransaction[]
  remainingAmount Decimal             @default(0)
  totalAmount     Decimal             @default(0)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @default(now()) @updatedAt
  deleted         Boolean             @default(false)
  deletedAt       DateTime?
}

model BudgetTransaction {
  id                  String    @id @unique @default(cuid())
  // The time when the transaction was made
  // ISO-8601 format
  timestamp           DateTime
  // The price of a single unit of the asset being bought or sold
  pricePerUnit        Decimal
  // The settlement currency in which the pricePerUnit is denominated
  // ISO-4217 format
  baseCurrency        String
  // The number of units of the asset being bought or sold
  quantity            Decimal
  // The number of units of the asset that have been filled in the transaction
  // (optional field, may not be applicable to all transactions)
  quantityFilled      Decimal?
  // The fee associated with the transaction in the base currency
  fee                 Decimal
  // The total value of the transaction in the base currency
  valueInBaseCurrency Decimal
  // The asset being sold in the transaction)
  fromAsset           String?
  // The asset being bought in the transaction
  // (optional field, may not be applicable to all 
  toAsset             String
  // The market in which the transaction took place
  market              String
  // The type of transaction (e.g. "buy", "sell", "referral_card_cashback")
  transactionType     String
  // The expiration time of the transaction, if applicable
  // ISO-8601 format
  expiry              DateTime?
  // The current status of the transaction (e.g. "filled", "cancelled")
  status              String
  // A unique identifier for the transaction
  transactionHash     String
  // A description of the transaction
  description         String
  // A memo associated with the transaction
  memo                String

  // Attached image
  imageUrl  String?
  imageName String?
  imageId   String?

  // A unique identifier for the order associated with the transaction. This could be useful for tracking and linking related transactions (e.g. multiple fills of a single order).
  // orderId   String?

  // The type of order associated with the transaction (e.g. "market", "limit", "stop"). This can be useful for understanding the conditions under which the transaction was made.
  // orderType String?

  // The limit price of a limit order, if applicable. This can be useful for understanding the conditions under which the order was placed and for determining whether the order was filled at the desired price.
  // limitPrice Decimal?

  budgetEnvelopeId String?
  budgetEnvelope   BudgetEnvelope? @relation(fields: [budgetEnvelopeId], references: [id])
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// ASSETS 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// You can use the term "financial asset" or "financial instrument" to refer to something that may be either an asset or a liability. These terms are commonly used in accounting and finance to refer to items that have a monetary value and can be used to measure, recognize, and record transactions or events. Financial assets may include cash, investments, or other assets that can be easily converted into cash, while financial liabilities may include debts or obligations that are owed to others.

// EG 
// const assets = await prisma.item.findMany({
//   where: {
//     type: AssetCategory.CRYPTOCURRENCY,
//     labels: {
//       some: {
//         name: "MyLabel",
//       },
//     },
//   },
//   orderBy: {
//     createdAt: "asc",
//   },
// })

// const liabilities = await prisma.item.findMany({
//   where: {
//     type: LiabilityCategory.MORTGAGE,
//     labels: {
//       some: {
//         name: "MyLabel",
//       },
//     },
//   },
//   orderBy: {
//     createdAt: "asc",
//   },
// })

// const customAssets = await prisma.item.findMany({
//   where: {
//     type: AssetCategory.CUSTOM,
//     customCategory: {
//       name: "MyCustomCategory",
//     },
//   },
//   orderBy: {
//     createdAt: "asc",
//   },
// })

enum Category {
  LOAN // represents a liability
  CASH // represents an asset
  CUSTOM // represents a custom asset or liability
  MORTGAGE
  PROPERTY
  SECURITY
  CREDIT_CARD
  CRYPTOCURRENCY
  SUPERANNUATION
}

model AssetCategory {
  id        String    @id @default(cuid())
  name      String
  icon      String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?
  assets    Asset[]
}

model AssetLabel {
  id        String    @id @default(cuid())
  name      String
  icon      String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?
  asset     Asset?    @relation(fields: [assetId], references: [id])
  assetId   String?
}

model Asset {
  id                     String    @id @default(cuid())
  // The name of the asset, such as "Bitcoin" or "Tesla Stock"
  name                   String
  // The currency that the asset is denominated in, such as "USD" or "EUR"
  currency               String
  // Credentials used to access data from an external API, such as an exchange's API.
  apiKey                 String?
  apiSecret              String?
  // The address of the wallet where the asset is stored, if applicable.
  walletAddress          String?
  // The current value of the asset, this is based on the market data of the specific asset and it can be fluctuating based on the market data.
  value                  Decimal
  valueLastUpdated       DateTime?
  // The balance of the asset, for example the number of shares or tokens that the user owns.
  balance                Decimal   @default(0)
  // The total cost of purchasing the asset, including any fees or expenses.
  costBasis              Decimal   @default(0)
  // The profit or loss from the sale of the asset, calculated as the sale price minus the cost basis.
  realisedGain           Decimal   @default(0)
  // The desired balance of the asset, for example the number of shares or tokens that the user wants to own.
  targetBalance          Decimal?
  // The balance of the asset that earns interest, for example a savings account balance.
  interestBearingBalance Decimal?
  // The income rate of the asset, for example the annual percentage rate of a savings account.
  incomeRate             Decimal?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  deleted   Boolean            @default(false)
  deletedAt DateTime?
  // An enumeration that represents the connection of the asset to an external account.
  account   AccountConnection?
  // An array of labels that can be used to classify the asset, such as "personal" or "business"
  labels    AssetLabel[]

  categoryId     String?
  category       Category
  // Reference to the category of the asset, for example "Cryptocurrency" or "Stock"
  customCategory AssetCategory? @relation(fields: [categoryId], references: [id])

  // Connection to market data for crypto, stock, metal prices etc.
  marketId String?
  market   Market? @relation(fields: [marketId], references: [id], onDelete: NoAction)

  // If the asset is a sub-asset, it will have a parent asset, these fields represent the parent asset
  parentId     String?
  parent       Asset?        @relation("sub_assets", fields: [parentId], references: [id])
  subAssets    Asset[]       @relation("sub_assets")
  transactions Transaction[]

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Transaction {
  id                  String    @id @unique @default(cuid())
  // The time when the transaction was made
  // ISO-8601 format
  timestamp           DateTime
  // The price of a single unit of the asset being bought or sold
  pricePerUnit        Decimal
  // The settlement currency in which the pricePerUnit is denominated
  // ISO-4217 format
  baseCurrency        String
  // The number of units of the asset being bought or sold
  quantity            Decimal
  // The number of units of the asset that have been filled in the transaction
  // (optional field, may not be applicable to all transactions)
  quantityFilled      Decimal?
  // The fee associated with the transaction in the base currency
  fee                 Decimal
  // The total value of the transaction in the base currency
  valueInBaseCurrency Decimal
  // The asset being sold in the transaction)
  fromAsset           String?
  // The asset being bought in the transaction
  // (optional field, may not be applicable to all 
  toAsset             String
  // The market in which the transaction took place
  market              String
  // The type of transaction (e.g. "buy", "sell", "referral_card_cashback")
  transactionType     String
  // The expiration time of the transaction, if applicable
  // ISO-8601 format
  expiry              DateTime?
  // The current status of the transaction (e.g. "filled", "cancelled")
  status              String
  // A unique identifier for the transaction
  transactionHash     String
  // A description of the transaction
  description         String
  // A memo associated with the transaction
  memo                String

  // A unique identifier for the order associated with the transaction. This could be useful for tracking and linking related transactions (e.g. multiple fills of a single order).
  // orderId   String?

  // The type of order associated with the transaction (e.g. "market", "limit", "stop"). This can be useful for understanding the conditions under which the transaction was made.
  // orderType String?

  // The limit price of a limit order, if applicable. This can be useful for understanding the conditions under which the order was placed and for determining whether the order was filled at the desired price.
  // limitPrice Decimal?

  relatedAssetId String?
  relatedAsset   Asset?  @relation(fields: [relatedAssetId], references: [id])
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// SNAPSHOTS - TODO: REFACTOR NEEDED 
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

model PortfolioSnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model CryptoSnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model CashSnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model PropertySnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model SecuritySnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

// EVERYTHING BELOW HERE SHOULD BE MERGED INTO THE ASSET SECTION AS ASSET SUPERCEDES CRYPTOCURRENCY 

model Cryptocurrency {
  id                     String             @id @unique @default(cuid())
  displayName            String
  currency               String             @default("usd")
  balance                Decimal            @default(0)
  costBasis              Decimal            @default(0)
  realisedGain           Decimal            @default(0)
  apiKey                 String?
  apiSecret              String?
  walletAddress          String?
  targetBalance          Decimal            @default(0)
  interestBearingBalance Decimal            @default(0)
  rateOfIncome           Decimal            @default(0)
  accountConnection      AccountConnection? @default(NONE)

  marketId  String?
  market    Market?          @relation(fields: [marketId], references: [id], onDelete: NoAction)
  parentId  String?
  parent    Cryptocurrency?  @relation("Cryptocurrency_Children", fields: [parentId], references: [id])
  Children  Cryptocurrency[] @relation("Cryptocurrency_Children")
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @default(now()) @updatedAt
  deleted   Boolean          @default(false)
  deletedAt DateTime?
}

enum MarketType {
  CRYPTOCURRENCY
  STOCK
  ETF
  METAL
  OTHER
  CASH
}

model Market {
  id                    String           @id @unique @default(cuid())
  name                  String
  ticker                String
  description           String?
  currency              String
  price                 Decimal          @default(0)
  priceChange24h        Decimal          @default(0)
  priceChange24hPercent Decimal          @default(0)
  marketCap             Decimal          @default(0)
  marketCapRank         Decimal          @default(0)
  type                  MarketType
  image                 String?
  Cryptocurrency        Cryptocurrency[]
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @default(now()) @updatedAt
  deleted               Boolean          @default(false)
  deletedAt             DateTime?
  Asset                 Asset[]

  @@unique([ticker, type])
}

enum AccountConnection {
  NONE
  SWYFTX
  COINSPOT
}
