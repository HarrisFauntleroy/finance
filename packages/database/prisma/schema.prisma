datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                String              @id @default(cuid())
  name              String?
  email             String?             @unique
  emailVerified     DateTime?
  image             String?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @default(now()) @updatedAt
  deleted           Boolean             @default(false)
  deletedAt         DateTime?
  role              Role                @default(USER)
  accounts          Account[]
  budget            Budget[]
  cryptocurrency    Cryptocurrency[]
  sessions          Session[]
  settings          Settings?
  portfolioSnapshot PortfolioSnapshot[]
  CryptoSnapshot    CryptoSnapshot[]
  CashSnapshot      CashSnapshot[]
  PropertySnapshot  PropertySnapshot[]
  SecuritySnapshot  SecuritySnapshot[]
}

model Log {
  id        String    @id @unique @default(cuid())
  type      LogType
  message   String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?
}

enum LogType {
  info
  warn
  error
  trace
  debug
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Settings {
  id                   String       @id @unique @default(cuid())
  userId               String       @unique
  preferredColorScheme ColorScheme? @default(LIGHT)
  userCurrency         String       @default("aud")
  userLanguage         String       @default("eng")
  user                 User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @default(now()) @updatedAt
  deleted              Boolean      @default(false)
  deletedAt            DateTime?

  @@unique([id, userId])
}

model Cryptocurrency {
  id                     String             @id @unique @default(cuid())
  displayName            String
  currency               String             @default("usd")
  balance                Decimal            @default(0)
  costBasis              Decimal            @default(0)
  realisedGain           Decimal            @default(0)
  apiKey                 String?
  apiSecret              String?
  walletAddress          String?
  targetBalance          Decimal            @default(0)
  interestBearingBalance Decimal            @default(0)
  rateOfIncome           Decimal            @default(0)
  accountConnection      AccountConnection? @default(NONE)

  marketId  String?
  userId    String
  parentId  String?
  market    Market?          @relation(fields: [marketId], references: [id], onDelete: NoAction)
  parent    Cryptocurrency?  @relation("Cryptocurrency_Children", fields: [parentId], references: [id])
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  Children  Cryptocurrency[] @relation("Cryptocurrency_Children")
  createdAt DateTime         @default(now())
  updatedAt DateTime         @default(now()) @updatedAt
  deleted   Boolean          @default(false)
  deletedAt DateTime?
}

model Market {
  id                    String           @id @unique @default(cuid())
  name                  String
  ticker                String
  description           String?
  currency              String
  price                 Decimal          @default(0)
  priceChange24h        Decimal          @default(0)
  priceChange24hPercent Decimal          @default(0)
  marketCap             Decimal          @default(0)
  marketCapRank         Decimal          @default(0)
  type                  MarketType
  image                 String?
  Cryptocurrency        Cryptocurrency[]
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @default(now()) @updatedAt
  deleted               Boolean          @default(false)
  deletedAt             DateTime?

  @@unique([ticker, type])
}

model Income {
  id             String    @id @unique @default(cuid())
  name           String
  payFrequency   String
  grossAmount    String
  grossFrequency String    @default("P1Y0M0DT0H0M0S")
  userId         String
  budget         Budget    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?
}

model Budget {
  id        String        @unique @default(cuid())
  name      String
  userId    String
  User      User          @relation(fields: [userId], references: [id])
  Children  BudgetAsset[]
  income    Income[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @default(now()) @updatedAt
  deleted   Boolean       @default(false)
  deletedAt DateTime?
}

model BudgetAsset {
  id        String    @unique @default(cuid())
  name      String
  type      String
  amount    String
  frequency String
  budgetId  String
  budget    Budget    @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?
}

enum ColorScheme {
  LIGHT
  DARK
  TBA
}

enum MarketType {
  CRYPTOCURRENCY
  STOCK
  ETF
  METAL
  OTHER
  CASH
}

enum AccountConnection {
  NONE
  SWYFTX
  COINSPOT
}

enum Role {
  USER
  ADMIN
}

// =-=-=-=-=-=-=-=-=-= Everything below is new =-=-=-=-=-=-=-=-=-=

// You can use the term "financial asset" or "financial instrument" to refer to something that may be either an asset or a liability. These terms are commonly used in accounting and finance to refer to items that have a monetary value and can be used to measure, recognize, and record transactions or events. Financial assets may include cash, investments, or other assets that can be easily converted into cash, while financial liabilities may include debts or obligations that are owed to others.

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// EG 
// const assets = await prisma.item.findMany({
//   where: {
//     type: AssetCategory.CRYPTOCURRENCY,
//     labels: {
//       some: {
//         name: "MyLabel",
//       },
//     },
//   },
//   orderBy: {
//     createdAt: "asc",
//   },
// })

// const liabilities = await prisma.item.findMany({
//   where: {
//     type: LiabilityCategory.MORTGAGE,
//     labels: {
//       some: {
//         name: "MyLabel",
//       },
//     },
//   },
//   orderBy: {
//     createdAt: "asc",
//   },
// })

// const customAssets = await prisma.item.findMany({
//   where: {
//     type: AssetCategory.CUSTOM,
//     customCategory: {
//       name: "MyCustomCategory",
//     },
//   },
//   orderBy: {
//     createdAt: "asc",
//   },
// })

enum Category {
  LOAN // represents a liability
  CASH // represents an asset
  CUSTOM // represents a custom asset or liability
  MORTGAGE
  PROPERTY
  SECURITY
  CREDIT_CARD
  CRYPTOCURRENCY
  SUPERANNUATION
}

model UserCategory {
  id        String    @id @default(cuid())
  name      String
  icon      String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?
  assets    Asset[]
}

model UserLabel {
  id        String    @id @default(cuid())
  name      String
  icon      String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deleted   Boolean   @default(false)
  deletedAt DateTime?
  asset     Asset?    @relation(fields: [assetId], references: [id])
  assetId   String?
}

model Asset {
  id             String        @id @default(cuid())
  name           String
  labels         UserLabel[]
  value          Decimal
  currency       String
  category       Category
  customCategory UserCategory? @relation(fields: [categoryId], references: [id])
  categoryId     String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @default(now()) @updatedAt
  deleted        Boolean       @default(false)
  deletedAt      DateTime?
}

model PortfolioSnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model CryptoSnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model CashSnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model PropertySnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

model SecuritySnapshot {
  id             String    @id @unique @default(cuid())
  currency       String
  totalValue     Decimal
  costBasis      Decimal
  unrealisedGain Decimal
  realisedGain   Decimal
  saleableValue  Decimal
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @default(now()) @updatedAt
  deleted        Boolean   @default(false)
  deletedAt      DateTime?

  @@unique([createdAt, userId])
}

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Transaction model
// Applies to all transactions, crypto trades, stock purchases, apples bought.

model Transaction {
  id                  String    @id @unique @default(cuid())
  // The time when the transaction was made
  // ISO-8601 format
  timestamp           DateTime
  // The price of a single unit of the asset being bought or sold
  pricePerUnit        Decimal
  // The settlement currency in which the pricePerUnit is denominated
  // ISO-4217 format
  baseCurrency        String
  // The number of units of the asset being bought or sold
  quantity            Decimal
  // The number of units of the asset that have been filled in the transaction
  // (optional field, may not be applicable to all transactions)
  quantityFilled      Decimal?
  // The fee associated with the transaction in the base currency
  fee                 Decimal
  // The total value of the transaction in the base currency
  valueInBaseCurrency Decimal
  // The asset being sold in the transaction)
  fromAsset           String?
  // The asset being bought in the transaction
  // (optional field, may not be applicable to all 
  toAsset             String
  // The market in which the transaction took place
  market              String
  // The type of transaction (e.g. "buy", "sell", "referral_card_cashback")
  transactionType     String
  // The expiration time of the transaction, if applicable
  // ISO-8601 format
  expiry              DateTime?
  // The current status of the transaction (e.g. "filled", "cancelled")
  status              String
  // A unique identifier for the transaction
  transactionHash     String
  // A description of the transaction
  description         String
  // A memo associated with the transaction
  memo                String

  // A unique identifier for the order associated with the transaction. This could be useful for tracking and linking related transactions (e.g. multiple fills of a single order).
  // orderId   String?

  // The type of order associated with the transaction (e.g. "market", "limit", "stop"). This can be useful for understanding the conditions under which the transaction was made.
  // orderType String?

  // The limit price of a limit order, if applicable. This can be useful for understanding the conditions under which the order was placed and for determining whether the order was filled at the desired price.
  // limitPrice Decimal?
}
